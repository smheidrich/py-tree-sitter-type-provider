input: talon
output: |-
  from_tree_sitter(self, tsnode: tree_sitter.Node) -> Union[Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]
  ERROR(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[typing.Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]] = <factory>) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Action(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, action_name: 'Identifier', arguments: 'ArgumentList') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  And(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('And'), ForwardRef('Match'), ForwardRef('Not')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  ArgumentList(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Action'), ForwardRef('BinaryOperator'), ForwardRef('Float'), ForwardRef('Integer'), ForwardRef('KeyAction'), ForwardRef('ParenthesizedExpression'), ForwardRef('SleepAction'), ForwardRef('String'), ForwardRef('Variable')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Assignment(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, left: 'Identifier', right: Union[ForwardRef('Action'), ForwardRef('BinaryOperator'), ForwardRef('Float'), ForwardRef('Integer'), ForwardRef('KeyAction'), ForwardRef('ParenthesizedExpression'), ForwardRef('SleepAction'), ForwardRef('String'), ForwardRef('Variable')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  BinaryOperator(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, left: Union[ForwardRef('Action'), ForwardRef('BinaryOperator'), ForwardRef('Float'), ForwardRef('Integer'), ForwardRef('KeyAction'), ForwardRef('ParenthesizedExpression'), ForwardRef('SleepAction'), ForwardRef('String'), ForwardRef('Variable')], operator: 'Operator', right: Union[ForwardRef('Action'), ForwardRef('BinaryOperator'), ForwardRef('Float'), ForwardRef('Integer'), ForwardRef('KeyAction'), ForwardRef('ParenthesizedExpression'), ForwardRef('SleepAction'), ForwardRef('String'), ForwardRef('Variable')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Block(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Assignment'), ForwardRef('Docstring'), ForwardRef('Expression')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Capture(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, capture_name: 'Identifier') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Choice(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Capture'), ForwardRef('EndAnchor'), ForwardRef('List'), ForwardRef('Optional'), ForwardRef('ParenthesizedRule'), ForwardRef('Repeat'), ForwardRef('Repeat1'), ForwardRef('Seq'), ForwardRef('StartAnchor'), ForwardRef('Word')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Command(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, rule: 'Rule', script: 'Block') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Comment(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Context(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('And'), ForwardRef('Docstring'), ForwardRef('Match'), ForwardRef('Not'), ForwardRef('Or')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Docstring(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  EndAnchor(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Expression(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, expression: Union[ForwardRef('Action'), ForwardRef('BinaryOperator'), ForwardRef('Float'), ForwardRef('Integer'), ForwardRef('KeyAction'), ForwardRef('ParenthesizedExpression'), ForwardRef('SleepAction'), ForwardRef('String'), ForwardRef('Variable')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Float(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Identifier(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  ImplicitString(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  IncludeTag(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, tag: 'Identifier') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Integer(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Interpolation(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: Union[ForwardRef('Action'), ForwardRef('BinaryOperator'), ForwardRef('Float'), ForwardRef('Integer'), ForwardRef('KeyAction'), ForwardRef('ParenthesizedExpression'), ForwardRef('SleepAction'), ForwardRef('String'), ForwardRef('Variable')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  KeyAction(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, arguments: 'ImplicitString') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  List(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, list_name: 'Identifier') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Match(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, key: 'Identifier', pattern: 'ImplicitString') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  NodeTransformer()
    transform(self, node: tree_sitter_type_provider.node_types.Node) -> ~Result
    transform_Action(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_And(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_ArgumentList(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Assignment(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_BinaryOperator(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Block(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Capture(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Choice(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Command(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Comment(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Context(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Docstring(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_ERROR(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_EndAnchor(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Expression(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Float(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Identifier(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_ImplicitString(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_IncludeTag(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Integer(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Interpolation(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_KeyAction(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_List(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Match(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Not(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Number(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Operator(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Optional(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Or(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_ParenthesizedExpression(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_ParenthesizedRule(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_RegexEscapeSequence(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Repeat(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Repeat1(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Rule(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Seq(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Settings(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_SleepAction(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_SourceFile(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_StartAnchor(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_String(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_StringContent(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_StringEscapeSequence(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Variable(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
    transform_Word(self, *, text: str, type: str, children: List[~Result] = [], **kwargs: Dict[str, Union[~Result, Sequence[tree_sitter_type_provider.node_types.Node], tree_sitter_type_provider.node_types.Node, NoneType]]) -> ~Result
  NodeVisitor()
    generic_visit(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Action(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_And(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_ArgumentList(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Assignment(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_BinaryOperator(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Block(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Capture(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Choice(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Command(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Comment(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Context(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Docstring(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_ERROR(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_EndAnchor(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Expression(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Float(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Identifier(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_ImplicitString(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_IncludeTag(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Integer(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Interpolation(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_KeyAction(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_List(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Match(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Not(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Number(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Operator(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Optional(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Or(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_ParenthesizedExpression(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_ParenthesizedRule(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_RegexEscapeSequence(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Repeat(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Repeat1(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Rule(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Seq(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Settings(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_SleepAction(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_SourceFile(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_StartAnchor(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_String(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_StringContent(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_StringEscapeSequence(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Variable(self, node: tree_sitter_type_provider.node_types.Node) -> None
    visit_Word(self, node: tree_sitter_type_provider.node_types.Node) -> None
  Not(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: 'Match') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Number(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: Union[ForwardRef('Float'), ForwardRef('Integer')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Operator(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Optional(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Capture'), ForwardRef('Choice'), ForwardRef('EndAnchor'), ForwardRef('List'), ForwardRef('Optional'), ForwardRef('ParenthesizedRule'), ForwardRef('Repeat'), ForwardRef('Repeat1'), ForwardRef('Seq'), ForwardRef('StartAnchor'), ForwardRef('Word')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Or(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('And'), ForwardRef('Match'), ForwardRef('Not')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  ParenthesizedExpression(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: Union[ForwardRef('Action'), ForwardRef('BinaryOperator'), ForwardRef('Float'), ForwardRef('Integer'), ForwardRef('KeyAction'), ForwardRef('ParenthesizedExpression'), ForwardRef('SleepAction'), ForwardRef('String'), ForwardRef('Variable')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  ParenthesizedRule(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Capture'), ForwardRef('Choice'), ForwardRef('EndAnchor'), ForwardRef('List'), ForwardRef('Optional'), ForwardRef('ParenthesizedRule'), ForwardRef('Repeat'), ForwardRef('Repeat1'), ForwardRef('Seq'), ForwardRef('StartAnchor'), ForwardRef('Word')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  RegexEscapeSequence(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: Optional[ForwardRef('RegexEscapeSequence')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Repeat(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: Union[ForwardRef('Capture'), ForwardRef('List'), ForwardRef('Optional'), ForwardRef('ParenthesizedRule'), ForwardRef('Repeat'), ForwardRef('Repeat1'), ForwardRef('Word')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Repeat1(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: Union[ForwardRef('Capture'), ForwardRef('List'), ForwardRef('Optional'), ForwardRef('ParenthesizedRule'), ForwardRef('Repeat'), ForwardRef('Repeat1'), ForwardRef('Word')]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Rule(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Capture'), ForwardRef('Choice'), ForwardRef('EndAnchor'), ForwardRef('List'), ForwardRef('Optional'), ForwardRef('ParenthesizedRule'), ForwardRef('Repeat'), ForwardRef('Repeat1'), ForwardRef('Seq'), ForwardRef('StartAnchor'), ForwardRef('Word')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Seq(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Capture'), ForwardRef('List'), ForwardRef('Optional'), ForwardRef('ParenthesizedRule'), ForwardRef('Repeat'), ForwardRef('Repeat1'), ForwardRef('Word')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Settings(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: 'Block') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  SleepAction(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, arguments: 'ImplicitString') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  SourceFile(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Command'), ForwardRef('Context'), ForwardRef('IncludeTag'), ForwardRef('Settings')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  StartAnchor(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  String(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, children: list[typing.Union[ForwardRef('Interpolation'), ForwardRef('StringContent'), ForwardRef('StringEscapeSequence')]]) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  StringContent(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  StringEscapeSequence(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Variable(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point, variable_name: 'Identifier') -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
  Word(text: str, type: str, start_position: tree_sitter_type_provider.node_types.Point, end_position: tree_sitter_type_provider.node_types.Point) -> None
    to_dict(self, encode_json=False) -> Dict[str, Union[dict, list, str, int, float, bool, NoneType]]
    to_json(self, *, skipkeys: bool = False, ensure_ascii: bool = True, check_circular: bool = True, allow_nan: bool = True, indent: Union[int, str, NoneType] = None, separators: Tuple[str, str] = None, default: Callable = None, sort_keys: bool = False, **kw) -> str
